newLogSigma <- rnorm(n = 1, mean = oldParams$logSigma, sd = qSigmaCovDiagSqrt)
newMu <- rnorm(n = 1, mean = oldParams$mu, sd = qSigmaCovDiagSqrt)
newThetas <- rnorm(n = numThetas, mean = oldParams$thetas, sd = rep(qSigmaCovDiagSqrt, numThetas))
return(list(thetas = newThetas, mu = newMu, logSigma = newLogSigma, logTau = newLogTau))
}
# start sampling
startParams <- list()
startParams$thetas <- c(60, 60, 60, 60)
startParams$mu <- 60
startParams$logSigma <- 0
startParams$logTau <- 0
numIters <- 1000000
storeEveryMultiple <- 1000
samples <- vector(mode="list", numIters/storeEveryMultiple)
samples[[1]] <- startParams
currentParams <- startParams
numAcceptances <- 0
for(i in 2:numIters){
proposal <- sampleQ(currentParams)
logAcceptRatio <- log_unnorm_post(proposal, y) - log_unnorm_post(currentParams, y)
if( log(runif(n=1)) < logAcceptRatio ){
cat("accepting\n")
currentParams <- proposal # change currentParams for next iter
numAcceptances <- numAcceptances + 1
}else{
cat("rejecting\n")
# don't change currentParams
}
if(i %% storeEveryMultiple == 0) # only store every tenth draw
samples[[i/storeEveryMultiple]] <- currentParams
cat("current log unnorm post dens: ", log_unnorm_post(currentParams, y), "\n")
}
cat("acceptance rate: ", numAcceptances/numIters)
apply(thetaSamples, 2, var)
# extract things and plot them
#library(GGally)
thetaSamples <- t(sapply(samples, "[[", 1))
plot.ts(thetaSamples)
ggpairs(as.data.frame(thetaSamples[-(1:500),]))
var(thetaSamples[,1])
var(thetaSamples[,2])
# try 1 first
qSigmaCovDiagSqrt <- 10000000  ## PRIMARY TUNING PARAMETER
sampleQ <- function(oldParams){
newLogTau <- rnorm(n = 1, mean = oldParams$logTau, sd = qSigmaCovDiagSqrt)
newLogSigma <- rnorm(n = 1, mean = oldParams$logSigma, sd = qSigmaCovDiagSqrt)
newMu <- rnorm(n = 1, mean = oldParams$mu, sd = qSigmaCovDiagSqrt)
newThetas <- rnorm(n = numThetas, mean = oldParams$thetas, sd = rep(qSigmaCovDiagSqrt, numThetas))
return(list(thetas = newThetas, mu = newMu, logSigma = newLogSigma, logTau = newLogTau))
}
# start sampling
startParams <- list()
startParams$thetas <- c(60, 60, 60, 60)
startParams$mu <- 60
startParams$logSigma <- 0
startParams$logTau <- 0
numIters <- 1000000
storeEveryMultiple <- 1000
samples <- vector(mode="list", numIters/storeEveryMultiple)
samples[[1]] <- startParams
currentParams <- startParams
numAcceptances <- 0
for(i in 2:numIters){
proposal <- sampleQ(currentParams)
logAcceptRatio <- log_unnorm_post(proposal, y) - log_unnorm_post(currentParams, y)
if( log(runif(n=1)) < logAcceptRatio ){
cat("accepting\n")
currentParams <- proposal # change currentParams for next iter
numAcceptances <- numAcceptances + 1
}else{
cat("rejecting\n")
# don't change currentParams
}
if(i %% storeEveryMultiple == 0) # only store every tenth draw
samples[[i/storeEveryMultiple]] <- currentParams
cat("current log unnorm post dens: ", log_unnorm_post(currentParams, y), "\n")
}
cat("acceptance rate: ", numAcceptances/numIters)
2.4^2/numThetas
sqrt(10000000)
# try 1 first
qSigmaCovDiagSqrt <- 3000  ## PRIMARY TUNING PARAMETER
sampleQ <- function(oldParams){
newLogTau <- rnorm(n = 1, mean = oldParams$logTau, sd = qSigmaCovDiagSqrt)
newLogSigma <- rnorm(n = 1, mean = oldParams$logSigma, sd = qSigmaCovDiagSqrt)
newMu <- rnorm(n = 1, mean = oldParams$mu, sd = qSigmaCovDiagSqrt)
newThetas <- rnorm(n = numThetas, mean = oldParams$thetas, sd = rep(qSigmaCovDiagSqrt, numThetas))
return(list(thetas = newThetas, mu = newMu, logSigma = newLogSigma, logTau = newLogTau))
}
# start sampling
startParams <- list()
startParams$thetas <- c(60, 60, 60, 60)
startParams$mu <- 60
startParams$logSigma <- 0
startParams$logTau <- 0
numIters <- 1000000
storeEveryMultiple <- 1000
samples <- vector(mode="list", numIters/storeEveryMultiple)
samples[[1]] <- startParams
currentParams <- startParams
numAcceptances <- 0
for(i in 2:numIters){
proposal <- sampleQ(currentParams)
logAcceptRatio <- log_unnorm_post(proposal, y) - log_unnorm_post(currentParams, y)
if( log(runif(n=1)) < logAcceptRatio ){
cat("accepting\n")
currentParams <- proposal # change currentParams for next iter
numAcceptances <- numAcceptances + 1
}else{
cat("rejecting\n")
# don't change currentParams
}
if(i %% storeEveryMultiple == 0) # only store every tenth draw
samples[[i/storeEveryMultiple]] <- currentParams
cat("current log unnorm post dens: ", log_unnorm_post(currentParams, y), "\n")
}
cat("acceptance rate: ", numAcceptances/numIters)
sqrt(5000000)
qSigmaCovDiagSqrt <- 2000  ## PRIMARY TUNING PARAMETER
sampleQ <- function(oldParams){
newLogTau <- rnorm(n = 1, mean = oldParams$logTau, sd = qSigmaCovDiagSqrt)
newLogSigma <- rnorm(n = 1, mean = oldParams$logSigma, sd = qSigmaCovDiagSqrt)
newMu <- rnorm(n = 1, mean = oldParams$mu, sd = qSigmaCovDiagSqrt)
newThetas <- rnorm(n = numThetas, mean = oldParams$thetas, sd = rep(qSigmaCovDiagSqrt, numThetas))
return(list(thetas = newThetas, mu = newMu, logSigma = newLogSigma, logTau = newLogTau))
}
# start sampling
startParams <- list()
startParams$thetas <- c(60, 60, 60, 60)
startParams$mu <- 60
startParams$logSigma <- 0
startParams$logTau <- 0
numIters <- 1000000
storeEveryMultiple <- 1000
samples <- vector(mode="list", numIters/storeEveryMultiple)
samples[[1]] <- startParams
currentParams <- startParams
numAcceptances <- 0
for(i in 2:numIters){
proposal <- sampleQ(currentParams)
logAcceptRatio <- log_unnorm_post(proposal, y) - log_unnorm_post(currentParams, y)
if( log(runif(n=1)) < logAcceptRatio ){
cat("accepting\n")
currentParams <- proposal # change currentParams for next iter
numAcceptances <- numAcceptances + 1
}else{
cat("rejecting\n")
# don't change currentParams
}
if(i %% storeEveryMultiple == 0) # only store every tenth draw
samples[[i/storeEveryMultiple]] <- currentParams
cat("current log unnorm post dens: ", log_unnorm_post(currentParams, y), "\n")
}
cat("acceptance rate: ", numAcceptances/numIters)
# try 1 first
qSigmaCovDiagSqrt <- 1000  ## PRIMARY TUNING PARAMETER
sampleQ <- function(oldParams){
newLogTau <- rnorm(n = 1, mean = oldParams$logTau, sd = qSigmaCovDiagSqrt)
newLogSigma <- rnorm(n = 1, mean = oldParams$logSigma, sd = qSigmaCovDiagSqrt)
newMu <- rnorm(n = 1, mean = oldParams$mu, sd = qSigmaCovDiagSqrt)
newThetas <- rnorm(n = numThetas, mean = oldParams$thetas, sd = rep(qSigmaCovDiagSqrt, numThetas))
return(list(thetas = newThetas, mu = newMu, logSigma = newLogSigma, logTau = newLogTau))
}
# start sampling
startParams <- list()
startParams$thetas <- c(60, 60, 60, 60)
startParams$mu <- 60
startParams$logSigma <- 0
startParams$logTau <- 0
numIters <- 1000000
storeEveryMultiple <- 1000
samples <- vector(mode="list", numIters/storeEveryMultiple)
samples[[1]] <- startParams
currentParams <- startParams
numAcceptances <- 0
for(i in 2:numIters){
proposal <- sampleQ(currentParams)
logAcceptRatio <- log_unnorm_post(proposal, y) - log_unnorm_post(currentParams, y)
if( log(runif(n=1)) < logAcceptRatio ){
cat("accepting\n")
currentParams <- proposal # change currentParams for next iter
numAcceptances <- numAcceptances + 1
}else{
cat("rejecting\n")
# don't change currentParams
}
if(i %% storeEveryMultiple == 0) # only store every tenth draw
samples[[i/storeEveryMultiple]] <- currentParams
cat("current log unnorm post dens: ", log_unnorm_post(currentParams, y), "\n")
}
cat("acceptance rate: ", numAcceptances/numIters)
# extract things and plot them
#library(GGally)
thetaSamples <- t(sapply(samples, "[[", 1))
plot.ts(thetaSamples)
ggpairs(as.data.frame(thetaSamples[-(1:500),]))
muSamples <- sapply(samples, "[[", 2)
plot.ts(muSamples)
logSigmaSamples <- sapply(samples, "[[", 3)
plot.ts(logSigmaSamples)
hist(exp(logSigmaSamples[-(1:200)]))
logTauSamples <- sapply(samples, "[[", 4)
plot.ts(logTauSamples)
#
pairs(cbind(logSigmaSamples, muSamples)[-(1:10),])
#
pairs(cbind(logSigmaSamples, muSamples)[-(1:100),])
y <- 2 # fake data
num_trials <- 1000
theta_proposals <- rt(num_trials, 1)
us <- runif(num_trials, min = 0, max = 1)
log_accept_prob <- function(theta){
-.5*(y - theta)^2
}
probs <- exp(log_accept_prob(theta_proposals))
accepts <- ifelse(us < probs, TRUE, FALSE)
accepts == us < probs
accepts == (us < probs)
knitr::opts_chunk$set(echo = TRUE)
library(quantmod)
getSymbols("SPY")
head(SPY)
Ad(SPY)
??returns
log(Ad(SPY))
rets <- diff(log(Ad(SPY)))
head(rets)
rets <- diff(log(Ad(SPY)))[-1]
head(rets)
rets <- 100*diff(log(Ad(SPY)))[-1]
head(rets)
write.table(rets, "ssme/example/spy_returns.csv", quote = F, header=F)
write.table(rets, "ssme/example/spy_returns.csv", quote = F)
write.table(rets, "ssme/example/spy_returns.csv", quote = F, row.names = F)
?write.table
write.table(rets, "ssme/example/spy_returns.csv", quote = F, row.names = F, col.names = F)
vec_storage(c(1,2,3), 2)
vec_storage(c(1,2,3), 2)
library(Rcpp)
sourceCpp("~/Desktop/tmp.cpp")
sourceCpp("~/Desktop/tmp.cpp")
sourceCpp("~/Desktop/tmp.cpp")
sourceCpp("~/Desktop/tmp.cpp")
sourceCpp("~/Desktop/tmp.cpp")
sourceCpp("~/Desktop/tmp.cpp")
sourceCpp("~/Desktop/tmp.cpp")
sourceCpp("~/Desktop/tmp.cpp")
y <- 1
theta <- 2
dnorm(y, 0,  exp(theta/2), log = T)
y <- c(1,2)
theta <- c(400,2)
dnorm(y, 0,  exp(theta/2), log = T)
y <- 1
theta <- c(400,2)
dnorm(y, 0,  exp(theta/2), log = T)
n <- 100
rnorm(n, 0, 1/n)
cumsum(rnorm(n, 0, 1/n))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
plot.ts(cumsum(rnorm(n, 0, 1/n)))
min(cumsum(rnorm(n, 0, 1/n)))
min(cumsum(rnorm(n, 0, 1/n))) < 3
min(cumsum(rnorm(n, 0, 1/n))) < 3
min(cumsum(rnorm(n, 0, 1/n))) < 3
min(cumsum(rnorm(n, 0, 1/n))) < 3
min(cumsum(rnorm(n, 0, 1/n))) < 3
min(cumsum(rnorm(n, 0, 1/n))) < -3
min(cumsum(rnorm(n, 0, 1/n))) < -3
min(cumsum(rnorm(n, 0, 1/n))) < -3
min(cumsum(rnorm(n, 0, 1/n))) < -3
function() min(cumsum(rnorm(n, 0, 1/n))) < -3
sapply(1:1000, function() min(cumsum(rnorm(n, 0, 1/n))) < -3)
sapply(1:1000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3)
sapply(1:1000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
sapply(1:1000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3)
mean(sapply(1:1000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
mean(sapply(1:1000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
mean(sapply(1:1000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
mean(sapply(1:10000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
mean(sapply(1:10000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
mean(sapply(1:10000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
mean(sapply(1:10000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
mean(sapply(1:10000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
n <- 1000; mean(sapply(1:10000, function(unused_arg) min(cumsum(rnorm(n, 0, 1/n))) < -3))
# markov function
markov <- function(init,mat,n,labels)
{
if (missing(labels))
{
labels <- 1:length(init)
}
simlist <- numeric(n+1)
states <- 1:length(init)
simlist[1] <- sample(states,1,prob=init)
for (i in 2:(n+1))
{
simlist[i] <- sample(states, 1, prob = mat[simlist[i-1],])
}
labels[simlist]
}
# matrixpower function
matrixpower <- function(mat,k)
{
if (k == 0) return (diag(dim(mat)[1]))
if (k == 1) return(mat)
if (k > 1) return( mat %*% matrixpower(mat, k-1))
}
tmat = matrix(c(0.1, 0.2, 0.4, 0.3,
0.4, 0.0, 0.4, 0.2,
0.3, 0.3, 0.0, 0.4,
0.2, 0.1, 0.4, 0.3), nrow=4, ncol=4, byrow=TRUE)
nn <- 10000
alpha <- c(0.25, 0.25, 0.25, 0.25)
steps10k <- markov(init=alpha, mat=tmat, n=nn)
plot.ts(cumsum(steps10k==2)/(1:steps10k))
1:3
cumsum(steps10k==2)
cumsum(steps10k==2)/(1:steps10k)
plot.ts(cumsum(steps10k==2)/(1:length(steps10k)))
plot.ts(cumsum(steps10k==2)/(1:length(steps10k)), main = "marginal probability of 2")
plot.ts(cumsum(steps10k==2)/(1:length(steps10k)),
main = "running percentage of time spent at 2",
ylab = "sample proportion",
xlab = "time")
tmat = matrix(c(0.1, 0.2, 0.4, 0.3,
0.4, 0.0, 0.4, 0.2,
0.3, 0.3, 0.0, 0.4,
0.2, 0.1, 0.4, 0.3), nrow=4, ncol=4, byrow=TRUE)
alpha <- c(0.25, 0.25, 0.25, 0.25)
nn <- 1000
steps10k <- markov(init=alpha, mat=tmat, n=nn)
plot.ts(cumsum(steps10k==2)/(1:length(steps10k)),
main = "running percentage of time spent at 2",
ylab = "sample proportion",
xlab = "time")
points(cumsum(markov(init=alpha, mat=tmat, n=nn)==2)/(1:length(steps10k), col = "red")
cumsum(markov(init=alpha, mat=tmat, n=nn)==2)/(1:length(steps10k)
)
points(cumsum(markov(init=alpha, mat=tmat, n=nn)==2)/(1:length(steps10k)), col = "red")
points(cumsum(markov(init=alpha, mat=tmat, n=nn)==2)/(1:length(steps10k)), col = "red", type = ".")
points(cumsum(markov(init=alpha, mat=tmat, n=nn)==2)/(1:length(steps10k)), col = "red", type = "p")
tmat = matrix(c(0.1, 0.2, 0.4, 0.3,
0.4, 0.0, 0.4, 0.2,
0.3, 0.3, 0.0, 0.4,
0.2, 0.1, 0.4, 0.3), nrow=4, ncol=4, byrow=TRUE)
alpha <- c(0.25, 0.25, 0.25, 0.25)
nn <- 1000
steps10k <- markov(init=alpha, mat=tmat, n=nn)
plot.ts(cumsum(steps10k==2)/(1:length(steps10k)),
main = "running percentage of time spent at 2",
ylab = "sample proportion",
xlab = "time")
points(cumsum(markov(init=alpha, mat=tmat, n=nn)==2)/(1:length(steps10k)), col = "red", type = "l")
plot.ts(cumsum(steps10k==2)/(1:length(steps10k)),
main = "running percentage of time spent at 2",
ylab = "sample proportion",
xlab = "time")
for(i in 1:10)
points(cumsum(markov(init=alpha, mat=tmat, n=nn)==2)/(1:length(steps10k)), col = i, type = "l")
install.packages("devtools")
devtools::install_github("tbrown122387/gradeR")
?gradeR
library(gradeR)
setwd("~/R/x86_64-pc-linux-gnu-library/3.4/gradeR/")
setwd("~/")
setwd("~/Desktop/")
setwd("~/")
gradeR("~/gradeR/example/assignment1_submissions/", "~/gradeR/example/grade_hw1.R")
traceback()
devtools::install_github("tbrown122387/gradeR")
library(gradeR)
gradeR("~/gradeR/example/assignment1_submissions/", "~/gradeR/example/grade_hw1.R")
devtools::install_github("tbrown122387/gradeR")
gradeR("~/gradeR/example/assignment1_submissions/", "~/gradeR/example/grade_hw1.R")
library(gradeR)
gradeR("~/gradeR/example/assignment1_submissions/", "~/gradeR/example/grade_hw1.R")
betas <- c(-1,2,-3)
x <- seq(-3,3,.1)
y_line <- cbind(x,x^2,x^3) %*% betas
y <- y_line +  rnorm(n = length(x), sd = 20)
plot(x,y)
points(x,y_line, col="red", type = "l")
plotSurface <- function(lowerFirst, upperFirst,
lowerSecond, upperSecond,
numGridPointsOnEachAxis, f, contour = F, ...){
A <- seq(lowerFirst, upperFirst, length.out = numGridPointsOnEachAxis)
B <- seq(lowerSecond, upperSecond, length.out = numGridPointsOnEachAxis)
args <- expand.grid(A,B)
z <- mapply(f, args[,1], args[,2])
dim(z) <- c(length(A), length(B))
if(contour){
contour(A, B, z)
}else{
persp(x=A, y=B, z=z, ...)
}
}
eval_mean <- function(x1, x2) -2 + 3*x1 - .2*x2 - 4*x1*x2
plotSurface(-5, 5, -5, 5, 50,
eval_mean, F, theta=-120,
zlab = "E[y]", xlab = "x1", ylab = "x2")
plotSurface <- function(lowerFirst, upperFirst,
lowerSecond, upperSecond,
numGridPointsOnEachAxis, f, contour = F, ...){
A <- seq(lowerFirst, upperFirst, length.out = numGridPointsOnEachAxis)
B <- seq(lowerSecond, upperSecond, length.out = numGridPointsOnEachAxis)
args <- expand.grid(A,B)
z <- mapply(f, args[,1], args[,2])
dim(z) <- c(length(A), length(B))
if(contour){
contour(A, B, z)
}else{
persp(x=A, y=B, z=z, ...)
}
}
eval_mean <- function(x1, x2) -2 + 3*x1 - .2*x2 - 4*x1*x2
plotSurface(-5, 5, -5, 5, 50,
eval_mean, T, theta=-120,
zlab = "E[y]", xlab = "x1", ylab = "x2")
plotSurface <- function(lowerFirst, upperFirst,
lowerSecond, upperSecond,
numGridPointsOnEachAxis, f, contour = F, ...){
A <- seq(lowerFirst, upperFirst, length.out = numGridPointsOnEachAxis)
B <- seq(lowerSecond, upperSecond, length.out = numGridPointsOnEachAxis)
args <- expand.grid(A,B)
z <- mapply(f, args[,1], args[,2])
dim(z) <- c(length(A), length(B))
if(contour){
contour(A, B, z)
}else{
persp(x=A, y=B, z=z, ...)
}
}
eval_mean <- function(x1, x2) (800+10*x1 + 7*x2+ 8.5*x1^2+ -5*x2^2+ 4*x1*x2)
plotSurface(0, 10, 0, 10, 50,
eval_mean, F, theta=-50,
zlab = "E[y]", xlab = "x1", ylab = "x2")
x <- seq(-10,10,1)
my_df <- data.frame(y = (3 + 2*x - 5*x^2) + rnorm(length(x), sd = 30), x = x)
head(my_df)
plot(my_df$x, my_df$y)
my_df$xsquared <- x^2
mlr_model <- lm(y ~ x + xsquared, data=my_df)
# mlr_model <- lm(y ~ . + xsquared, data=my_df) # . means "all other columns"
summary(mlr_model)
fitted_vals <- predict(mlr_model)
plot(my_df$x, my_df$y)
points(my_df$x, fitted_vals, col = "red", type ="l")
knitr::include_graphics("/home/t/UVa/all_teaching/summer19_6021/presentations/module3/screenshot.png")
# knitr::include_graphics("screenshot.png")
mlr_model
anova(mlr_model)
names(anova(mlr_model))
anova(mlr_model)$'Mean Sq'
names(mlr_model)
install.packages("installr"); library(installr) # install+load installr
q()
setwd("~/gradeR/")
library(devtools)
install.packages("devtools")
install.packages("knitr")
library(devtools)
devtools::install_github("tbrown122387/gradeR")
devtools::load_all("~/gradeR/")
devtools::check()
devtools::load_all("~/gradeR/")
devtools::check()
install.packages("rmarkdown")
devtools::check()
devtools::check_win_devel()
devtools::check_rhub()
devtools::check()
devtools::build_vignettes()
devtools::build()
devtools::use_vignette("gradeR-vignette")
usethis::use_vignette("gradeR-vignette")
devtools::check()
usethis::use_vignette("gradeR")
devtools::release()
devtools::spell_check()
devtools::spell_check("~/gradeR/")
install.packages("spelling")
library(spelling)
devtools::spell_check("~/gradeR/")
?spell_check
devtools::spell_check("~/gradeR/")
devtools::release()
devtools::release()
devtools::load_all()
devtools::release()
3
devtools::release()
devtools::release()
devtools::release()
use_cran_comments()
devtools::release()
devtools::build()
devtools::load_all()
devtools::release()
